                                           TypeScript 
//////////////////////////////////////////////////////////////////////////////////////////////

What is typescript?

 Typescript is object oriented and functional style programming language.
 Typescript that scales javascript.
 scaling is nothing but expanding features.
 Typescript is super set of Javascript.

What is Javascript?

 -Javascript is programming language.


Styles of programming language
 -Object oriented
 -Procedure oriented
 -Functional oriented
 -Event driven

Some languages designed with single style - c++,java,C#,c
Some languages designed with multiple styles (hybrid) - Javascript,java 8,C#,Scala,Groovy,Kotiln....

"Javascript is Object based,functional Style,Event driven programming language."

Object based vs Object oriented:
...............................

Object Oriented Principles:
...........................

1.Abstraction
2.Encapsulation
3.Hierarchy
4.Typing
5.Modularity
----------------------
6.Concurrency
7.Persistency

if any language follows the first 5 prinicples 100% , those languages are called object
oriented programming.

if any language  does not follow the first 5 prinicples 100% or if follwing paritally , those languages are called object based programming.

functional pure vs style:

-if any language follows 100% functional programming principles those languages are called
"purely functional",if not functional style.

/////////////////////////////////////////////////////////////////////////////////////////////

Javascript features:

 -Typing
     Dynamic typed language / weak typed language -----javascript
        The type of variable is not verified during compile time, runtime verfication.

     var x ="hello"
      x=10;

     Static typed language/ Strongly typed language -  c,c++,c#,java......
       The type of variable is verified during compile time.

eg:
  int a =100
  int a ="hello"; invalid ;compile time error.

  var/let/const a =10;
  a="hello" ;valid

Think: why js was designed to be dynamic typed?


 Drawbacks of dynamic typing:
    -We cant build enterprise consistent application.

 -Object based 
    if we  want to design , object oriented system in js not possible.

Why javascript:
  Javascript was created for process html pages.

1989 - Web Project was started    -------Sun created Java

1990 -  The first webserver,Browser was created

1994 - Netscap started

1995 - The first netscap navigator came to access web pages 

1996 - Netscap decided to put java inside web browser.

static web page- before netscap
dynamic web page -netscap

----Static web----- only hand coded html pages.

1996 - CREATED Dynamic web : how to work with databases
     - CGI - C,perl.
 J2EE- Servlets,JSP
 MS  - ASP
 OPEN SOURCE - PHP.

 Server side web : create html pages on fly by including data from databases.

Netscap decided to build client side web technoloy- once html is rendered into web browser
how to change that html onfly. 

Netscap decided to create a new programming language, who recurited Brendan Eich
,the programmer , asked to create new programming language for netscap navigator.

-Objective of Project

-It should be like java but it should not be java -light weight - scripting
-deadline is 10 days.

Time line:

1.javascript project started 1995

1.first name of the language was "Mocha"
2.language was renamed to "Live Script" -1996
3.language was renamed to "java Script" -1996

After language ready, which was submitted to standard body "ECMA international"

1996---1997 : JS 1.0 =>ES 1.0

1997- 1998 :  ES 2.0: It did not come

1999 :  ES 3

2007 : ES 4

2008 : ES 5

2012-2015 : ES 6

2016  ONWARDS : es 7,es 8, ......


////////////////////////////////////////////////////////////////////////////////////////////

javascript and enterprise computing:

 -After introduction of node.js, javascript started scalling in enterprise computing.
in order to build enterprise apps, we need perfect oo implementations

in order to create better javascript, 2009, The project was started to make javascript looks like other object oriented langugages

  - classes,interfaces,modules.... : Coffee script.

if you write coffee script, how to run it? 
  browsers and node understands only js.

how to run coffee script  ?
   compile coffee script into javascript and run it.

 hello.coffee----compile it(transpiler)-----hello.js---run on browser/node
..........................................................................................

..........................................................................................

2010, Microsoft started project to create object oriented javascript using C#

Objective of MS Project:

 -Add Type System - Strong Typing
 -Classes
 -Modules
 -interfaces
 -encapulation keywords
 .......
C# ---compiler------plain javascript.

MS Failed to port this project to public because


Problems with C#
 1.PORTABLITY.
 2.COMPLEXITY

2012 - ECMA released new javascript spec (ES 6) in which They introduced
  
   - classes
   - let 
   - const
   - advanced object literals
   - Promises
  etc..........

MS decided to rewrite Typed Javascript project based "ECMA 6 Standards".

MS Started redesigning the whole project, target ecma 6 as base language.

{ES 6 + Static Typing + added new extra fetures} => The brith of Typescript.



Arch of TS:

					
				      TS language
					    |
					  ES 6
					    |
					  ES 5


Typescript----compile----Plain javascript

Typescript is strongly typed, object oriented  javascript.

Now you can use type script to build better object oriented systems using javascript.

TS is not compititor or replacer for javascript but it complements js.

/////////////////////////////////////////////////////////////////////////////////////////

Type scrit is a typed superset of javascript that compiles to plain javascript

                  any browser,any host, any os, any device

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////

Lab:

Create Ts Project.
How to write ts programs
How to compile ts programs
How to run compiled ts programs


mkdir tsapps
C:\session\ibm\2021\may\angular>mkdir tsapps


cd tsapps

lanuch code window

C:\session\ibm\2021\may\angular\tsapps>code .


create package.json file

>npm init

install typescript compiler

>npm install typescript --save-dev


create source dir

>mkdir src

create ts programs - fileName.ts

src/index.ts

console.log("hello")

compile ts program

-add compiler config

package.json

 "compile": "tsc src/index.ts"

tsc-compiler name

>npm run compile

-generates js file

How to test ?

-on node and also browser

->on node
C:\session\ibm\2021\may\angular\tsapps>node src/index.js
Hello Type script!!!

->on browser

lanuch webbrowser and see console

///////////////////////////////////////////////////////////////////////////////////////////

Typescript compiler(Transpiler): 
   Transpiler means source code to source code conversion -  ts -js

syntax

  tsc --compileroptions filename.ts

compiler options can be supplied in line or in a file(tsconfig.json)

Use case:

Separate sourcode and compiled code into different directories.

Use case:

Separate sourcode and compiled code into different directories.

source code
 src
   -index.ts

 build
    -index.js

how to tell the compiler to place compiled code into build folder.

compiler options:

 syntax

  tsc --compileroptions filename

  tsc --outDir build   src/index.ts



{
  "name": "mytsapps",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "compile" : "tsc --outDir build   src/index.ts"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "typescript": "^3.9.5"
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////

Use case: if i write code ,every time i need to compile program mannually how to avoid that.

 we compiler option 
   --watch

 "scripts": {
    "build" : "tsc --watch --outDir build   src/index.ts"
  }

/////////////////////////////////////////////////////////////////////////////////////////////

**************************************************************************************

what if i want to add more and more compiler options


tsc --watch --outDir build  --options --options  src/index.ts
  
 This is not scaleable, and maintainable. , if configuration grows.

Solution : 
 we need to create simple ts config file where you can place all configurations.

create file called
 tsconfig.json outside src folder, where we can tell all compiler options


{
    "compilerOptions": {
        "outDir": "build",
        "watch": true
    },
    "files": [
        "src/index.ts"
    ]
}
////////////////////////////////////////////////////////////////////////////////////////////////
ES 6 core concepts:

Variable delcaration;

var - es 5
let  - es6 
const - es6

var is not block scoped and let and const is block scoped.

In ES6 APPS  let and const are recommended.

The problems with ES 6:

When es6 was introduced, the node and browsers vendors were not ready to accept
es6 keywords

 let ,const never work in older node and browsers.

that time browers were supported only ES 5 version of js.

browsers were not ready that time, but develoers felt,and supported lot on es6.

Then how to run es 6 code on browsers which dont support.

The birth of "Transpilers"  : a special compilers which converts es6 to es5,

developer write code in es6 ---->transpiler-->es 5

eg: babel.js 
 higer version -to lower version

eg : tsc
 es6 to es5
 +
 type verification

         "ts compiler by default converts es6 code into es5."

let---------var

what if i dont to convert es6 to es 5, i want to keep same version?

{
    "compilerOptions": {
        "outDir": "build",
        "watch": true,
        "target": "ES6"
    },
    "files": [
        "src/index.ts"
    ]
}
///////////////////////////////////////////////////////////////////////////////////////////


Literals:
 since js is dynamic typed, types of the variable is identified during runtime based on literal(values)

1.number
2.string
3.boolean
4.undefined
5.NaN
6.infinity
7.null
8.function
9.object

1.strings:

1.16 bit unicode charaters.

2.strings can be declared inside  "" or ''  or ``(back-tick) es 6 feature
   "" : inspired from java and c++
   '' : js specific notation.


//string
let firstName = "Subramanian";
let lastName = 'Murugan'
//console.log("First Name" + firstName);
console.log(`First Name ${firstName} ${lastName}`);
let title = 'HR BLCOK'
let htmlPage =`
    <html>
      <head>
       <title>
          ${title}
       </title>
     </head>
     <body>
      <h1>Welcome</h1>
     </body>
     </html>
`;
console.log(htmlPage);
///////////////////////////////////////////////////////////////////////////////////////////

Numbers:

1.number size is 64 bit by default aka double.
2.It is IEEE 754 Standard.

No int ,long,float,double only one type - number type - 

//Numbers 
let a = 100;
let b = 200;

Booleans:

1.represents true or false 
2.1 bit value.

//booleans 
let isValid = true;
let isEnabled = false;


//undefined:
undefined:
..........
It is value, assigned to a variable, if no valid literal is assigned.


let firstName;
let price;
let qty;
console.log(`First Name ${firstName}`);
console.log(`price ${price} ${qty}`);


1.NaN :Not a Number 

Not a Number but is number.
NaN represents error code.
NaN error code will come due to "numerical compuation failures".

Note:

 if you get NaN as out put, it is danger/toxic , it is runtime error, you need to fix.

When NaN will come?
 
let price;
let qty;
console.log(`First Name ${firstName}`);
console.log(`price ${price} ${qty}`);

//NaN ; it is error code , will come during numerical computation

let totalPrice = price * 1000;
console.log(`Total Price ${totalPrice}`)


Type conversion : string to number

types of Type conversion

1.implicit Type conversion
 js automatically converts string to number
2.explicit Type conversion
 js uses conversion utility apis to convert string to number.


let count = "10"; // it string type but value is numerical value

//Type conversion happened here; implicit conversion
let totalCount = count * 10;
console.log(`Total Count ${totalCount}`);

//Type conversion using js built in api.
//double(64 bit) to 32 bit(integer)
let totalCounter = parseInt(count) * 10;
console.log(`Total Count ${totalCounter}`);
let totalCounterdouble = parseFloat(count,16) * 10;
console.log(`Total Count ${totalCounterdouble}`);


//Nan and type conversion
// here $100 is not numerical so during type conversion, error is thrown.
let stockValue = "$100";
let totalStock  = parseInt(stockValue) * 100;
console.log(`Total Stock ${totalStock}`);
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

Data Types and Javascript :

How do i know the type of a variable?

typeof operator is used to know the type of variable.
typeof operator returns the type name in smaller case. eg "string,number,undefined,booelean"

//string
let firstName = "Subramanian";
let lastName = 'Murugan'
//console.log("First Name" + firstName);
console.log(`First Name ${firstName} ${lastName}`);
let title = 'HR BLCOK'
let htmlPage = `
    <html>
      <head>
       <title>
          ${title}
       </title>
     </head>
     <body>
      <h1>Welcome</h1>
     </body>
     </html>
`;
console.log(htmlPage);

//Numbers 
let a = 100;
let b = 200;

//booleans 
let isValid = true;
let isEnabled = false;

//undefined
let price;
let qty;
console.log(`First Name ${firstName}`);
console.log(`price ${price} ${qty}`);

//NaN ; it is error code , will come during numerical computation

let totalPrice = price * 1000;
console.log(`Total Price ${totalPrice}`)

//type conversion
let count = "$10" //string
let totalCount = parseInt(count) * 10;
console.log(totalCount)

//infinity
//div by 0
let newprice = 1000;
let avgPrice = newprice / 0;
//Avg Price Infinity
console.log(`Avg Price ${avgPrice}`);

//typeof operator ; tells the type of variable

console.log(`First Name Type ${typeof firstName}`) // string
console.log(`a Type ${typeof a}`) // string
console.log(`totalPrice(NaN) ${typeof totalPrice}`) // string
console.log(`avgPrice(Infinity) ${typeof avgPrice}`) // string
console.log(`isValid Type ${typeof isValid}`) // string
console.log(`price(undefined) ${typeof price}`) // string

/////////////////////////////////////////////////////////////////////////////////////////////

JS Types:

1.string
2.number - NaN,infinity
3.undefined
4.boolean
5.function
6.object - null,object

/////////////////////////////////////////////////////////////////////////////////////////////

Strong Typing:
.............

/////////////////////////////////////////////////////////////////////////////////////////////

Typescript and type system:
...........................

Strong typing:
Type script introduces data types which can be used to verfify the compile time code viloations.

Type annotations:
  types

Type script offers the follow type annotations

primitive datatypes
1.string
2.number
3.boolean

Object types:

Object
Array
Enum

Other types
void
any
unknown
Function

Syntax  of strongly typed

var/let/const variable:type = literal

int a =10;

a = "hello" ;;compiler will throw error : compile time vertification.


eg:

//string 

let firstName: string = "Hello";
let lastName:string =100

[9:39:45 AM] File change detected. Starting incremental compilation...

src/index.ts:6:5 - error TS2322: Type 'number' is not assignable to type 'string'.

6 let lastName:string =100
      ~~~~~~~~

[9:39:46 AM] Found 1 error. Watching for file changes.


Type erasor/:
 Types will be erased after compilation; any ts specific notations will not be available 
after code is compiled.


index.ts
//strong 

//string 
let firstName: string = "Hello";
//let lastName:string =100
let age: number = 18;
let isEnabled: boolean = true;	

index.js
//strong 
//string 
var firstName = "Hello";
//let lastName:string =100
var age = 18;
var isEnabled = true;


Ways of type declaration :

1.expilicit
  let variableName:type = value

2.implicit : Type inference

   if any variable is assigned with specific type value

 let variableName = value


//how to declare variable and how to initalize

//declare and initalize in the same line
let firstName: string = "Subramanian";

//declared variable
let lastName: string;
lastName = "Murugan";

//reinitlize 
//lastName =100;
////////////////////////////////////////////////////////////////////////////
//type inference;

//once the variable declare and initalized with any value, that value type is 
//implicitly assinged , in future assignment if you have different type , will not 
// be allowed
let price = 100;
price = 200
//price = "Hello"

//what if i want js like syntax; no type is forced
//way -1
//undefined ; once if variable is declare with undefined , later any type can be assinged
let qty;
qty = 100;
qty = "Hello"

//way-2 ; any means no type is forced or if you dont know type in advance
let value: any;
value = 100;

value = "Hello"

value = true;

//////////////////////////////////////////////////////////////////////////////
let stock:undefined
//stock =100;

/////////////////////////////////////////////////////////////////////////////////////////


Typescript compiler and compile time errors:


-if any compile time error found, the compiler will show error, starts transpiling the code
 -default behaviour
 
what if i want to enforce if there is any compile time, dont emmit code

 "noEmitOnError":true

////////////////////////////////////////////////////////////////////////////////////////////

const :
 -read only
once if the variable is assinged , you cant reinitalize.

/////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////

return type



//return type is infered based on values
function getMessage() {
    return "Hello";
}
console.log(getMessage())

//return type is also infered based on parameters
function getValue(value: any) {
    return value;
}
console.log(getValue(100))
console.log(getValue("test"))

//explicit type
function getValue1(value: string): string {
    return value;
}
console.log(getValue1("100"))

function getValue2(value: string): any {
    return value;
}
console.log(getValue2("100"))

//dont want return ; dont keep without any type;

function doStuff(value: string): void {
    console.log(value)
    // return; //empty return is void
}
doStuff("100");

// let add = (a: number, b: number): number => {
//     return a + b;
// }
//only line of code; only return statement;remove {} and return statement
let add = (a: number, b: number): number => a + b;
console.log(add(1, 1))
////////////////////////////////////////////////////////////////////////////////////////////


Optional,required,default args:
...............................


let greet = (name: string, message: string, when: string): void => {
    console.log(`name ${name} message ${message} when ${when}`)
};
greet("subramanian");



src/index.ts:5:1 - error TS2554: Expected 3 arguments, but got 1.

5 greet("subramanian");
  ~~~~~~~~~~~~~~~~~~~~

  src/index.ts:2:28
    2 let greet = (name: string, message: string, when: string): void => {
                                 ~~~~~~~~~~~~~~~
    An argument for 'message' was not provided.

what if i want to skip rest of the parameters?

1.optional parameter ? ts feature


//optional parameters; parameters can be skipped
let greet = (name: string, message?: string, when?: string): void => {
    console.log(`name ${name} message ${message} when ${when}`)
};
greet("subramanian");

2.default args ; e6 feature

//default args
let greetMe = (name: string = "name", message: string = "message", when: string = "when"): void => {
    console.log(`name ${name} message ${message} when ${when}`)
};
greetMe()
greetMe("Ram")
greetMe("Ram","hello","today")
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

Union type:
..........
function args type can be mixed ; either this or that

for eg : id variable may be string or number - 

 id: string | number


function printId(id: number | string) {
    console.log("Your ID is: " + id);
}
printId(100)
printId("100")


function printId(id: number | string) {
    console.log(id.toUpperCase());

}
Property 'toUpperCase' does not exist on type 'string | number'.
    Property 'toUpperCase' does not exist on type 'number'.

TypeScript will only allow you to do things with the union if that thing is valid for every member of the union. For example, if you have the union string | number, you canâ€™t use methods that are only available on string:

Narrowing:
how to work with this? narrowing:

The solution is to narrow the union with code, the same as you would in JavaScript without type annotations. Narrowing occurs when TypeScript can deduce a more specific type for a value based on the structure of the code.


//function uniion type

function printId(id: number | string) {
    console.log("Your ID is: " + id);
}
printId(100)
printId("100")
//printId(true) //error
// function printId(id: number | string) {
//     console.log(id.toUpperCase());

// }
// Property 'toUpperCase' does not exist on type 'string | number'.
//     Property 'toUpperCase' does not exist on type 'number'.

function printId1(id: number | string) {
    if (typeof id === "string") {
        // In this branch, id is of type 'string'
        console.log(id.toUpperCase());
    } else {
        // Here, id is of type 'number'
        console.log(id.toFixed());
    }
}
printId1(100)
printId1(123.86789);
printId1("abc")

function welcomePeople(x: string[] | string) {
    if (Array.isArray(x)) {
        // Here: 'x' is 'string[]'
        console.log("Hello, " + x.join(" and "));
    } else {
        // Here: 'x' is 'string'
        console.log("Welcome lone traveler " + x);
    }
}
welcomePeople("subramanian")
welcomePeople(['subu','ram'])
/////////////////////////////////////////////////////////////////////////////////////////////

Object oriented Programming concepts and implementation:
........................................................
    //declare class  -  instance variables,constructors, instance methods,static variables,methods

    class Employee {
    //instance variables
    id:number =1;
    name:string ="subramanian"
    isWorking:boolean = true;
    salary:number =1000

    //instance methods
    calculateSalary(noofdays:number=0):number{
        return this.salary * noofdays;
    }
    }

    //create object
    //emp is reference variable
    //let is keyword
    //new is operator
    //Employee() - fun call -  constructor call
    let emp = new Employee();
    console.log(emp.id,emp.name,emp.isWorking,emp.calculateSalary(23))

/////////////////////////////////////////////////////////////////////////////////////////

state initalization:

->direct /hardcoded

->after object creation

->through constructor.


->direct /hardcoded

->after object creation


class Employee {
    //direct hardcoded
    id: number = 1
    name: string = "Subramanian";
    isWorking: boolean = true;
    //instance methods
    calculateSalary(): number {
        return 1000;
    }
}
//emp is just reference variable
//new is operator to create instance
//Employee() constructor call.
let emp = new Employee();
console.log(emp.id, emp.name, emp.isWorking, emp.calculateSalary())
//after object creation
emp.id = 900;
emp.name ="ram"
emp.isWorking =false
//emp.id ="hello" //erro
console.log(emp.id, emp.name, emp.isWorking, emp.calculateSalary())

//////////////////////////////////////////////////////////////////////////////////////////

init via constructors:

//constructor

class Employee {
    //just declare variable
    id: number
    name: string
    isWorking: boolean;
    //constructor args variables ; local variables
    constructor(id: number, name: string = "foo", isWorking: boolean = false) {
        this.id = id;
        this.name = name;
        this.isWorking = isWorking;
    }
    //instance methods
    calculateSalary(): number {
        return 1000;
    }
}
//let emp = new Employee(1);
let emp = new Employee(1, "subramanian", true);

console.log(emp.id, emp.name, emp.isWorking, emp.calculateSalary())
////////////////////////////////////////////////////////////////////////////////////////////

Encapsulation:

What is encasulation?

To Prevent code sharing from one code to another.

code - collection of classes, variables,functions,......

code is represented inside file.

pl provides keywords to ensure that , how  we can allow the code to be shared

TS provides keywords to prevent code sharing
 
 -public - any where
 -private - with in class 
 -protected - with in class + inheritance

only class members are public/private/protected.

---if you declare any member(var,methods) => by default is public.

1.Explicit public:

//by default all instance members are public;

class Employee {
    //just declare variable
    public id: number
    public name: string
    public isWorking: boolean;
    //constructor args variables ; local variables
    constructor(id: number, name: string = "foo", isWorking: boolean = false) {
        this.id = id;
        this.name = name;
        this.isWorking = isWorking;
    }
    //instance methods
    public calculateSalary(): number {
        return 1000;
    }
}
let emp = new Employee(1, "subramanian", true);

console.log(emp.id, emp.name, emp.isWorking, emp.calculateSalary())


private :

class AuthService {
    private password: string = "Abbb3333434"
}
let authService = new AuthService();
console.log(authService.password);


src/index.ts:7:25 - error TS2341: Property 'password' is private and only accessible within class 'AuthService'.

7 console.log(authService.password);
                          ~~~~~~~~



//private 

class AuthService {
    private password: string = "Abbb3333434"

    private generatePassword() {
        return '88822dwwewewe';
    }

    public getPass(): string {
        return this.generatePassword() + this.password
    }

}
let authService = new AuthService();
//console.log(authService.password);
//console.log(authService.generatePassword());
console.log(authService.getPass())
//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////

variables types:

1.instance variable
  variable declared inside class
2.local variables
  variables are declared inside method(including constructor)
  or method args / constructor args

default scope of instance variables  all are public

Note:
 how to reduce variable declarations inside class (instance variable declaration)

Typescript provides a facility to "Treat local variable as instance variable: constructor 
args"

 constructor args can be converted from local to instance variables

 why : to reduce code.

How to convert local variables into instance variables?

 "Add" -public / private keywords in the constructor args


class Employee {
    //just declare variable
    // public id: number
    // public name: string
    // public isWorking: boolean;
    //constructor args variables ; instance variables
    constructor(public id: number, public  name: string = "foo", public isWorking: boolean = false) {
        this.id = id;
        this.name = name;
        this.isWorking = isWorking;
    }
    //instance methods
    public calculateSalary(): number {
        return 1000;
    }
}
let emp = new Employee(1, "subramanian", true);

console.log(emp.id, emp.name, emp.isWorking, emp.calculateSalary())


Still we can reduce code

class Employee {
    constructor(public id: number, public name: string = "foo", public isWorking: boolean = false) { }
    //instance methods
    public calculateSalary(): number {
        return 1000;
    }
}

let emp = new Employee(1, "subramanian", true);

console.log(emp.id, emp.name, emp.isWorking, emp.calculateSalary())
/////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////

Hierachy : HAS-A dependency injection && is-a : inheritance
..........................................................

HAS- A : dependency injection :
...............................

//has-a dependency injection.

class Product {
    constructor(public id: number = 1, public name: string = 'product-1') {

    }
}
class Order {
    constructor(public orderId: number = 1, public product: Product = new Product()) {
    }
}


class Employee{

}

let order = new Order();
console.log(order.orderId, order.product.name);

let order1 = new Order(12, new Product(90, 'Computers'));
console.log(order1.orderId, order1.product.name);

// let order2 = new Order(45, new Employee()); error because type is invalid.

///////////////////////////////////////////////////////////////////////////////////////////
IS-A - inheritance:

Type script offers various base classes

1.concrete class 
2.interface
3.abstract classes



///////////////////////////////////////////////////////////////////////////////////////////

IS-A - inheritance:

Type script offers various based classes

1.concrete class 
2.interface
3.abstract classes



Basic inheritance:
//IS -A  inheritance:

class Account {
    protected myvar: string = "Account class"
    
    constructor(public id: string, public minbalance: number) {
        console.log('Account')
    }
    protected getBank(): string {
        return 'MyBank'
    }
}
class SavingsAccount extends Account {
    constructor(id: string = "A001", minbalance: number = 0) {
        super(id, minbalance); //call base class constructor
        console.log("Savings Account" + this.myvar)
    }
    public displayBankDetails(): string {
        return this.getBank();
    }
    public displayAccountDetails(): string {
        return `Account details ${this.id} ${this.minbalance}`
    }
}

let sb = new SavingsAccount();
//console.log(sb.myvar);
console.log(sb.displayBankDetails());
//console.log(sb.getBank())
console.log(sb.displayAccountDetails());


overriding:
//overriding / method defining

class Account {
    constructor() {
        console.log('account class')
    }
    protected getBalance(): number {
        return 100;
    }
}
class SavingsAccount extends Account {
    constructor() {
        super();
        console.log('account class')
    }
    //override
    public getBalance(): number {
        return 1000 + super.getBalance();
    }

}
let sb = new SavingsAccount();
console.log(sb.getBalance())
////////////////////////////////////////////////////////////////////////////////////////////
interfaces:
...........

eat
fly

animal  bird

fly
bird  airplan  superman batman 

common behavioiur which is in unrelated family of classes - interfaces.

interface  InterfaceName{
   method();
}
implements keywords

interface Flyable {
    fly(whoisFlyling: string): string;
}

interface Landing {
    land(whoisLanding: string): string;
}

class Bird implements Flyable, Landing {
    fly(whoisFlyling: string): string {
        return whoisFlyling;
    }
    land(whoisLanding: string): string {
        return whoisLanding
    }
}
class Jet implements Flyable, Landing {
    fly(whoisFlyling: string): string {
        return whoisFlyling;
    }
    land(whoisLanding: string): string {
        return whoisLanding
    }
}
let bird = new Bird();
console.log(bird.fly('Bird is flying'))
console.log(bird.land('Bird is landing'))

let jet = new Jet();
console.log(jet.fly('Jet is flying'))
console.log(jet.land('Jet is landing'))

////////////////////////////////////////////////////////////////////////
abstract classs:

  common behavioiur which is in related family of classe.
  -unimplmented methods and implemented methods.

//abstract class 

interface Flyable {
    fly(whoisFlyling: string): string;
}

abstract class Bird implements Flyable {
    constructor() {
        console.log('Bird is initalized')
    }
    //abstract method
    protected abstract buildNest(whoBuildNest: string): string;
    //concrete method
    public saveBirds(): string {
        return 'Save Birds from Hunter'
    }
    fly(whoisFlyling: string): string {
        return whoisFlyling;
    }
}
class Crow extends Bird {
    constructor() {
        super();
    }
    public buildNest(whoBuildNest: string): string {
        return whoBuildNest;
    }
    fly(whoisFlyling: string): string {
        return whoisFlyling;
    }

}
class Warbler extends Bird {
    constructor() {
        super();
    }
    public buildNest(whoBuildNest: string): string {
        return whoBuildNest;
    }
}

let bird = new Crow();
console.log(bird.saveBirds(), bird.buildNest('Crow'))
let bird1 = new Crow();
console.log(bird1.saveBirds(), bird1.buildNest('WarBler'))
////////////////////////////////////////////////////////////////////////////////////////////

Array:
-It is built in object
-It is basic dyanamic ds.
-It can hold any type of data.

I want to store array of numbers.

1.normal syntax
         let list:number[] = [1,2,3,4];

2.generics syntax <>
  
     let list:Array<number> = [1,2,3,4];
  

////////////////////////////////////////////////////////////////////////////////////////////

Arrays:
.......

Array is object, instance of Array class


Arrays Types:
.............

1.normal syntax
let list:number[] = [1,2,3,4];
2.generics syntax

//array types

//let list: number[] = [1, 2, 3, 4, "hello"]; error

let list: Array<number> = [1, 2, 3, 4, 5];

let names: Array<string> = ["a", "b"];

//array of Products

class Product {
    id: number;
    name: string;
    price?: number;
    qty?: number;
}


let products: Array<Product> = [
    { id: 1, name: 'a1', price: 100, qty: 23 },
    { id: 2, name: 'a2', price: 100, qty: 23 },
    { id: 3, name: 'a3', price: 100, qty: 23 },
    { id: 4, name: 'a4', price: 100, qty: 23 },
    { id: 5, name: 'a5', price: 100, qty: 23 }

];
let products1: Product[] = [
    { id: 1, name: 'a1', price: 100, qty: 23 },
    { id: 2, name: 'a2', price: 100, qty: 23 },
    { id: 3, name: 'a3', price: 100, qty: 23 },
    { id: 4, name: 'a4', price: 100, qty: 23 },
    { id: 5, name: 'a5', price: 100, qty: 23 }
];
////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////

Arrays:
.......

Array is object, instance of Array class


Arrays Types:
.............

1.normal syntax
let list:number[] = [1,2,3,4];
2.generics syntax

//array types

//let list: number[] = [1, 2, 3, 4, "hello"]; error

let list: Array<number> = [1, 2, 3, 4, 5];

let names: Array<string> = ["a", "b"];

//array of Products

class Product {
    id: number;
    name: string;
    price?: number;
    qty?: number;
}


let products: Array<Product> = [
    { id: 1, name: 'a1', price: 100, qty: 23 },
    { id: 2, name: 'a2', price: 100, qty: 23 },
    { id: 3, name: 'a3', price: 100, qty: 23 },
    { id: 4, name: 'a4', price: 100, qty: 23 },
    { id: 5, name: 'a5', price: 100, qty: 23 }

];
let products1: Product[] = [
    { id: 1, name: 'a1', price: 100, qty: 23 },
    { id: 2, name: 'a2', price: 100, qty: 23 },
    { id: 3, name: 'a3', price: 100, qty: 23 },
    { id: 4, name: 'a4', price: 100, qty: 23 },
    { id: 5, name: 'a5', price: 100, qty: 23 }
];
////////////////////////////////////////////////////////////////////////////////////////////
enumeration: named constant

//Enum
enum Direction {
    Up,
    Down,
    Left,
    Right,
}
console.log(Direction.Up)
console.log(Direction.Down)

enum UserResponse {
    No = 0,
    Yes = 1,
}

function respond(recipient: string, message: UserResponse): void {
    // ...
    console.log(recipient, message)
}

respond("Princess Caroline", UserResponse.No);
//////////////////////////////////////////////////////////////////////////////////////////////


Decorators:
..........

annotations: @annotation , @Override,@Entity,@Controller

-meta programming : isloate the code logic from main program to ouside, when you 
req, you inject those features , into code during runtime.

Decorators are experimental feature in es7. but ts added this language with experimental
mode.

How to create our own decorators?

Steps:

1.declare decorator
  function , based on syntax
2.use the decorator
  you can use on class,method,field
  @functionname.


Steps:

//decorators : 

//declare decorator

function Course(target: any) {
    console.log('Course decorator is activated')
}

//apply decorator/annotate

@Course
class Student {
    constructor() {

    }
}
let student = new Student();

src/index.ts:12:7 - error TS1219: Experimental support for decorators is a feature that is subject to change in a future release. Set the 'experimentalDecorators' option in your 'tsconfig' or 'jsconfig' to remove this warning.

12 class Student {
         ~~~~~~~


{
    "compilerOptions": {
           "experimentalDecorators": true,
          "emitDecoratorMetadata": true
    },
    "files": [
        "src/index.ts"
    ]
}

////////////////

Decorator logic and error
//decorators : 

//declare decorator

function Course(target: any) {
    console.log('Course decorator is activated')
    //logic for decorator
    Object.defineProperty(target.prototype, "subject", {
        value: 'Typescript'
    });

}

//apply decorator/annotate

@Course
class Student {
    constructor(public firstName: string, public lastName: string) { }
}
let student = new Student("Subramanian", "Murugan");
console.log(`${student.firstName} ${student.lastName} is learning ${student.subject} `)


[9:40:01 am] File change detected. Starting incremental compilation...

src/index.ts:21:77 - error TS2339: Property 'subject' does not exist on type 'Student'.

21 console.log(`${student.firstName} ${student.lastName} is learning ${student.subject} `)


Here typescript compiler is telling that , i am not able to findout "subject" is part of Student Type


How to fix this problem? how to tell ts compiler dont worry this is runtime property.

 "type alise" : as
 

full decorator:
//decorators : 

//declare decorator

function Course(target: any) {
    console.log('Course decorator is activated')
    //logic for decorator
    Object.defineProperty(target.prototype, "subject", {
        value: 'Typescript'
    });

}

class CourseType {
    firstName?: string;
    lastName?: string;
    subject?: string;
}

//apply decorator/annotate

@Course
class Student {
    constructor(public firstName: string, public lastName: string) { }
}
// let student = new Student("Subramanian", "Murugan") as CourseType
let student = new Student("Subramanian", "Murugan") as any //type coericion
console.log(`${student.firstName} ${student.lastName} is learning ${student.subject} `)
////////////////////////////////////////////////////////////////////////////////////////////

How to pass parameter - string,object
How to decorate multiple decorators


//decorator with input

function Course(courseName: string) {
    //logic should be inside  inner function, that function should be returned
    return function (target: any) {
        //logic for decorator
        Object.defineProperty(target.prototype, "subject", {
            value: courseName
        });
    }
}
type TeacherType = {
    id: number,
    name: string
}
function Teacher(teacher: TeacherType) {
    //logic should be inside  inner function, that function should be returned
    return function (target: any) {
        //logic for decorator
        Object.defineProperty(target.prototype, "trainer", {
            value: teacher
        });
    }
}

@Course('Rxjs')
@Teacher({ id: 1, name: 'Karthik' })
class Student {
    constructor(public firstName: string, public lastName: string) { }
}
// let student = new Student("Subramanian", "Murugan") as CourseType
let student = new Student("Subramanian", "Murugan") as any //type coericion
console.log(`${student.firstName} ${student.lastName} is learning ${student.subject} from ${student.trainer.name} `)
//
////////////////////////////////////////////////////////////////////////////////////////////

Field level decorator:
.......................

function Course(courseName: string = 'Type Script') {
    return function (target: any) {
        //biz logic
        Object.defineProperty(target.prototype, 'courseName', { value: courseName })
    }

}

function Input(label: string) {
    //target would be object(Student) and key would be firstName ...
    return function (target: any, key: string) {
        //logic
        Object.defineProperty(target, key, {
            get: () => label
        });
    }
}



@Course()
class Student {
    @Input('Subramanian')
    firstName;
    @Input('Murugan')
    lastName;
    constructor(firstName?: string, lastName: string = '') {
    }
}
let student = new Student() as any;
console.log(`${student.firstName} ${student.lastName} is learning ${student.courseName}`)

////////////////////////////////////////////////////////////////////////////////////////////

Method level : 
 decorator is added on top of method.

function Course(courseName: string = 'Type Script') {
    return function (target: any) {
        //biz logic
        Object.defineProperty(target.prototype, 'courseName', { value: courseName })
    }

}

function Input(label: string) {
    //target would be object(Student) and key would be firstName ...
    return function (target: any, key: string) {
        //logic
        Object.defineProperty(target, key, {
            get: () => label
        });
    }
}

function expandAble(value: boolean = true) {
    return function (target: any, prop: any, propdescriptor: PropertyDescriptor) {
        propdescriptor.writable = value;
        console.log('target',target);
        console.log('prop',prop);
        console.log('propdescriptor',propdescriptor)
    }
}


@Course()
class Student {
    @Input('Subramanian')
    firstName;
    @Input('Murugan')
    lastName;
    constructor(firstName?: string, lastName: string = '') {
        this.firstName = firstName
        this.lastName = lastName;
    }
    @expandAble(false)
    public calculateCost(): number {
        return 1000;
    }
}
let student = new Student() as any;
console.log(`${student.firstName} ${student.lastName} is learning ${student.courseName}`)
console.log(`Cost for the course ${student.calculateCost()}`)
//new cost ; this is default overriding; what if nobody should override.
student.calculateCost = function () {
    return 100;
};
console.log(`Cost for the course ${student.calculateCost()}`)
//////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

Modularity:
..........

javascript is fundamentally does not have modularity like c,c++,java,C#

How to organize code into different files and folders and how to link them and how to share them.

c++ - header files
java - packages
c# - namespaces

javascript - file based 

-inside file, code is global by default
 so i include many files, there is possiblity code clash.

eg:
 a.js
   function sayGreet(){}

 b.js
   function sayGreet(){}

<script src="a.js">
<script src="b.js">
 here only b.js saygreet will be taken.

JS ;
1. has no language level modular design for file loading ,linking , sharing

2.Javascript engine provides simple loader which can load one .js file at a time.

3.If file has linking with other file,that also should be loaded separtly.

How to solve this issue?

Via module design patterns.

1.Namespace design pattern : which is core design pattern helps to organize code sharing only
 
 ->how to encapsulate the code
 which uses js core concept called "literal object/iife)"

2.AMD

3.CJS
//////////////////////////////////////////////////////////////////////////////////////////////

4.ES 6 Module design pattern

////////////////////////////////////////////////////////////////////////////////////////////
5.System

6.UMD

Two design patterns only available in development:

1.cjs - used in node.js

2.es6 modules
   can be used in browser
   can be used in node
 no direct implementation available in both env. we need loader.

 loader is lib /program which will help to convert module specfic code into browser or node
understandable format.

cjs is built in node js, so we dont need any extra loaders.

Loaders:
 -webpack
 -rollup
/////////////////////////////////////////////////////////////////////////////////////////////

E6 modularity and typescript 

 typescript supports e6 modularity.

 ts compiler con  convert es 6 module into cjs,amd,system,umd.

 ts compiler by default convert es6 modules into cjs.

es 6 modularity  has keywords:

code sharing
1.export
2.export default

file linking
import 

what could be the code

 -variables,functions,classes,interfaces,types......



eg:

mock-data.ts


//code; share 
export const firstName:string ='Subramanian'

mock-data.js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.firstName = void 0;
//code; share 
exports.firstName = 'Subramanian';


index.ts

import { firstName } from './mock-data';

console.log(firstName)

index.js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mock_data_1 = require("./mock-data");
console.log(mock_data_1.firstName);


in order to run cjs/es6 inside browser , we need loader ; webpack.

webpack:

>npm install webpack webpack-cli --save-dev


>webpack.config.js
const path = require('path');

module.exports = {
    entry: './build/index.js',
    mode: 'development',
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js',
    },

};

>package.json
 "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "compile": "tsc",
    "build": "webpack --watch"
  }
npm run build
>index.html

    <script src="dist/bundle.js"></script>


  
export vs export default

 export - multi export
 export default - single export.

modularity patterns:

organize the code into folders

src
 |
 folder
 folder
 folder
index.ts

eg:
 controller -----service ---uses models

eg:
src
  -types
    todo.type.ts

export class Todo {
    userId: number;
    id: number;
    title?: string;
    completed?: boolean;
}

src
 -mock-data
    -todos.ts

export const TODOS: Array<Todo> = [
    {
        userId: 1,
        id: 1,
        title: "delectus aut autem",
        completed: false
    },
    {
        userId: 1,
        id: 2,
        title: "quis ut nam facilis et officia qui",
        completed: false
    }]
services
  -todoservice.ts
import { TODOS } from '../mock-data/todos';
import { Todo } from '../types/todotype';

export class TodoService {
    constructor() {

    }
    findAll(): Array<Todo> {
        return TODOS;
    }
}

controller/todo.controller.ts
import { TodoService } from '../services/todo.service';
import { Todo } from '../types/todotype';

// //dependency injection
// export class TodoController {
//     todoService: TodoService;
//     //TodoService
//     constructor(todoService: TodoService) {
//         this.todoService = todoService;
//     }
//     //controller api
//     findAll(): Array<Todo> {
//         return this.todoService.findAll();
//     }
// }
//dependency injection
export class TodoController {
    //TodoService
    constructor(private todoService: TodoService) { }
    //controller api
    findAll(): Array<Todo> {
        return this.todoService.findAll();
    }
}

src/
 index.ts

//main
import { TodoController } from './controller/todo.controller';
import { TodoService } from './services/todo.service';

const main = () => {
    let todoService = new TodoService();
    //di
    let ctrl = new TodoController(todoService);
    console.log(ctrl.findAll())
}
main();
////////////////////////////////////////////////////////////////////////////////////////////


































